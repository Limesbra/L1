# Вопросы и ответы

## Вопрос 1
**Q:**  Какой самый эффективный способ конкатенации строк?

**A:** Есть следующие способы конкатенации строк:

*  Использование оператора “+”;
*  `func Join(elems []string, sep string) string`
*  Builder

Самый оптимальный из данных способов это Builder, т.к. Builder используется для эффективного построения строки с использованием методов Builder.Write. Это сводит к минимуму копирование памяти.
Первые два способа каждый раз создают новую строку, снижая производительность.


## Вопрос 2
**Q:** Что такое интерфейсы, как они применяются в Go?

**A:** Это абстракция которая описывает поведение других типов. Интерфейс описывает поведение, но не реализует его.
Интерфейс представляет своего рода контракт, которому должен соответствовать тип данных. Чтобы тип данных соответствовал некоторому интерфейсу, данный тип должен реализовать в виде методов все функции этого интерфейса. 
В Go интерфейс реализуется неявно. Нам не надо специально указывать, что структуры применяют определенный интерфейс, как в некоторых других языках программирования. Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс.
Интерфейсы позволяют писать более гибкие функции, которые не зависят от конкретного типа аргумента


## Вопрос 3
**Q:** Чем отличаются RWMutex от Mutex?

**A:** Главные отличия заключаются в контроле доступа к данным, Mutex полностью блокирует доступ к ресурсам, при помощи метода Lock и разблокирует методом Unlock. RWMutex имеет предыдущие два метода, а также имеет метод RLock и RUnlock, данные методы позвляют управлять доступом к записи в ресурсы, но оставить возможность чтения ресурсов.


## Вопрос 4
**Q:** Чем отличаются буферизированные и не буферизированные каналы?

**A:** Для создания небуферизированного канала вызывается функция make() без указания емкости канала.
Чтение или запись данных в небуферизированный канал блокирует горутину и контроль передается свободной горутине.
Буферизированные каналы также создаются с помощью функции make(), только в качестве второго аргумента в функцию передается емкость канала. Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.
При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.


## Вопрос 5
**Q:** Какой размер у структуры struct{}{}?

**A:** Размер у такой структуры 0 байт. Может применяться для мапы, где нам важны ключи, а не значения


## Вопрос 6
**Q:** Есть ли в Go перегрузка методов или операторов?

**A:** Нет. Вместо перегрузки используются интерфейсы.


## Вопрос 7
**Q:** В какой последовательности будут выведены элементы map[int]int?
```
Пример:\
m[0]=1 \
m[1]=124 \
m[2]=281 
```

**A:** Элементы map[int]int в Go не гарантируют порядок итерации. При каждом запуске программы порядок итерации может быть разным.


## Вопрос 8
**Q:** В чем разница make и new?

**A:** Они используются в разных ситуациях и имеют свои особенности. new инициализирует нулевое значение для данного типа и возвращает указатель на этот тип. make используется исключительно для создания и инициализации срезов, мап и каналов, не возвращает указатель в отличие от new.


## Вопрос 9
**Q:** Сколько существует способов задать переменную типа slice или map?


**A:** \
slice - 6 шт
* var s []int
* s := []int{}
* s := []int{1, 2, 3}
* s := make([]int, 0)
* s := make([]int, 0, 5)
* s := new(int[])

map - 5 шт
* var m map[int]bool
* m := map[int]bool{1:true}
* m := make(map[int]bool)
* m := make(map[int]bool, 10)
* m := new(map[int]bool)


## Вопрос 10
**Q:** Что выведет данная программа и почему?
```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

**A:** вывод будет 1 и 1, т.к. в функции update мы передаем копию указателя, чтобы изменить p нужно передать указатель на указатель


## Вопрос 11
**Q:** Что выведет данная программа и почему?
```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

**A:** Мы получим deadlock потому что мы передаем структуру WaitGroup в функцию по значению, она копируется, и вызов wg.Done() внутри горутины не изменит счетчик WaitGroup в главной функции. Следовательно, главная горутина навсегда зависнет на wg.Wait()


## Вопрос 12
**Q:** Что выведет данная программа и почему?
```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

**A:** мы получим 0 потому что в if создается новая область видимости в которой создается еще одна переменная n и инкрементируется, после выхода из if это n удалится. Блок if не затрагивает n из более глобальной области, поэтому мы получаем 0


## Вопрос 12
**Q:** Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

**A:** вывод - [100 2 3 4 5]. Передавая слайс в функцию по значению, он копируется, но поля остаются теми же. Поэтому мы можем изменить значения элементов. В исходном слаесе нет элемента со значение 6 т.к. изначальная емкость слайса это 5 элементов. Функция аппенд проверяет если емкости недостаточно, то память перевыделяется и возвращается новый массив, поэтому в исходном массиве нет элемента со значением 6


## Вопрос 14
**Q:** Что выведет данная программа и почему?
```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

**A:** вывод - [b b a][a a]
В данной программе анонимной функции передается через параметры слайс, то есть он копируется. Меняя этот слайс мы не меняем слайс в главной функции.
